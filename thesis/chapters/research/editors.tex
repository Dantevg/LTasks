\section{Task types and editors}\label{section-editors}

\todo{TODO: clean up this section: maybe divide into editor (types) and task types}

\subsection{Editors in iTasks}
Since iTasks is written in the statically typed language Clean, a task can only have a predetermined set of values (true/false, numbers, dates, choices, \dots). This is useful for generating a web interface with typed editors, because it allows you to make use of the existing HTML form input fields. This is useful for two reasons. First, these form fields only allow valid input, i.e. you can't input arbitrary text in a number field. Second, they improve usability by adapting the input method, for instance displaying a date picker.

This generation of different HTML form fields can be done automatically because in a statically typed language the types are available statically, before any value is present.
% the types are bound to the fields or variables, not with the values themselves. The consequence of this is that, since the 

\subsection{Typed editors in Lua}\label{section-editors-lua}
Lua is dynamically typed, so a variable or field can hold any type of value at any point in time. A function can take any number of arguments and return any number of values of any type. Type information is also not attached to variables/fields, but to the values. The consequence of this is that there is no type information present when there are no values yet---a field in a table without any value (i.e. the table key is assigned \lua{nil}) simply does not exist. In order to work with this in a useful way, here are some ideas:

\subsubsection{Adding types}
The programmer would specify which type a task or field is supposed to have. The type information could be given in a format similar to JSON schema\footnote{\label{footnote-json-schema}\url{https://json-schema.org/}}. This type information would be attached as meta-information to a task, and checked dynamically. This idea basically comes down to emulating a statically typed language and comes closest to how iTasks handles TOP. It allows the implementation to automatically generate editor UI that is appropriate and specific to the type of value.

I think this is a weird direction to go into for a dynamically typed language. Instead of choosing this method in Lua, it would be a better idea to use a statically typed language. Or, instead of trying to fight the dynamic language, we should embrace it. This is what the other ideas do.
% Opinion: maybe a bit weird, why not use a statically typed language? Maybe it can be interesting to allow specifying multiple possible types.

\subsubsection{Validator / conversion functions}
Do not specify types, but validate or convert task input. A task that increments a number could for example use a \lua{tonumber()} validator / conversion function.
% A number-only field could for example be replaced by a field with a \lua{tonumber()} validator / converter function.

Since there is no information about what type of data a task expects, it is impossible to automatically generate type-specific editors. Instead, the user is in charge of selecting the right editor type. The user interface could allow the user to change the input method (for example from text to a list).

This could be a useful and versatile way to enter information. For example entering a date could be done in these ways:
\begin{itemize}
    \item Basic text field: \lua{"2022-03-31"}
    \item Date picker
    \item Three number fields ``year'', ``month'', ``day'':\\\lua{{year = 2022, month = 3, day = 31}}
\end{itemize}

This does make use of dynamic typing, but I doubt this is really useful. Especially the usability will be a problem since the user has to select the right editor type manually, which is even worse for composite data structures.

\subsubsection{Interface with JSON APIs}
The de-facto communication format of the web, JSON\footnote{\url{https://www.json.org/json-en.html}}, is also dynamic (when not using JSON schema\footref{footnote-json-schema}). JSON could be a good companion to TOP in the dynamic language Lua, as all concepts in JSON map directly to Lua concepts: numbers, strings, booleans, arrays (tables), objects (tables) and null (nil). It could be used to communicate with all kinds of JSON web APIs, such as ones providing weather conditions, address information or public transit information.

Tasks will not have any type information attached and can simply fail when their input is not in a format they can work with. They can do this because we can rely on JSON APIs to yield the right format if there was no error.

This approach however means that there will no longer be an interactive component for users. This is problematic because we just defined (in section \ref{section-top-lua}) that interactive editors are an essential component of TOP. While JSON can be hand-written by users as input to an editor, doing that is not very user-friendly compared to the alternatives.

\subsubsection{Structural type matching}
A different way to make use of the dynamic-ness of Lua is to provide multiple continuation tasks to the step combinator, where each continuation has an associated type which it accepts. The step combinator can then employ a matching algorithm to find which task it should execute based on the value of the previous task.
The matching algorithm should not only match the primitive type, but should also be able to match more complex structures like lists, or tables with specific fields.

There are many different ways to design such a matching algorithm, as there are many design considerations. When multiple tasks would match some value, the algorithm could find the first match, or the best match. Finding the best match requires defining a measure of match quality. What happens to tables that have more fields than the task requires?

You may think that an editor task before a step combinator can use the type information of tasks after the combinator to automatically deduce the right editor type to display. However, this goes against the TOP principle that tasks are autonomous: they do not depend on other tasks. What we can do is manually make a different editor for each type of output.

This is the direction we will go into for this thesis, for the following reasons:
it keeps the core concepts of TOP with user interaction,
it makes use of the dynamic typing of Lua,
it works in a way that is not possible with the current TOP implementations
% in the statically typed functional language Clean,
and lastly I think it is the most interesting and novel idea.

\subsection{Tables in editors}
Tables can be visually represented as a sequence of key-value pairs, with a ``$+$'' button for adding a new pair and a ``$-$'' button for removing a pair. A value without key could act as an array entry. These entries would implicitly get a numeric key, just like in Lua. These elements can be displayed one after the other, without keys displayed.
