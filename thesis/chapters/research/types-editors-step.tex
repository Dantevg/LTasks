\section{Task types for editors and step}\label{section-types-editors-step}

\todo{TODO: clean up this section: maybe divide into editor (types) and task types}

\subsection{Editors in iTasks}
Since iTasks is written in the statically typed language Clean, a task can only have a predetermined set of values (true/false, numbers, dates, choices, \dots). This is useful for generating a web interface with typed editors, because it allows you to make use of the existing HTML form input fields. This is useful for two reasons. First, these form fields only allow valid input, i.e. you can't input arbitrary text in a number field. Second, they improve usability by adapting the input method, for instance displaying a date picker.

This generation of different HTML form fields can be done automatically because in a statically typed language the types are available statically, before any value is present.
% the types are bound to the fields or variables, not with the values themselves. The consequence of this is that, since the 

\subsection{Typed editors in Lua}\label{section-editors-lua}
Lua is dynamically typed, so a variable or field can hold any type of value at any point in time. A function can take any number of arguments and return any number of values of any type. Type information is also not attached to variables/fields, but to the values. The consequence of this is that there is no type information present when there are no values yet---a field in a table without any value (i.e. the table key is assigned \lua{nil}) simply does not exist.
Because of this fundamental difference between Clean and Lua, we need to rethink and redesign the TOP concepts as used in iTasks. Below we explore the design space.

\subsubsection{Adding types}
The programmer specifies which type a task or field is supposed to have. The type information is given in a format similar to JSON schema\footnote{\label{footnote-json-schema}\url{https://json-schema.org/}}. This type information is then attached as meta-information to a task, and checked dynamically. This idea basically comes down to emulating a statically typed language and comes closest to how iTasks handles TOP. It allows the implementation to automatically generate editor UI that is appropriate and specific to the type of value.

I think this is a weird direction to go into for a dynamically typed language. Instead of choosing this method in Lua, it would be a better idea to use a statically typed language. Or, instead of trying to fight the dynamic language, we should embrace it. This is what the other ideas do.
% Opinion: maybe a bit weird, why not use a statically typed language? Maybe it can be interesting to allow specifying multiple possible types.

\subsubsection{Validator / conversion functions}
Do not specify types, but validate or convert task input. A task that increments a number could for example use a \lua{tonumber()} validator / conversion function.
% A number-only field could for example be replaced by a field with a \lua{tonumber()} validator / converter function.

Since there is no information about what type of data a task expects, it is impossible to automatically generate type-specific editors. Instead, the user is in charge of selecting the right editor type. The user interface allows the user to change the input method (for example from text to a list).

This is a useful and versatile way to enter information. For example entering a date can be done in these ways, with each of them having their own function to check if the format is correct:
\begin{itemize}
    \item Basic text field: \lua{"2022-03-31"}
    \item Date picker (with a function that outputs the date in one of these other formats)
    \item Three number fields \lua{year}, \lua{month} and \lua{day}:\\\lua{{year = 2022, month = 3, day = 31}}
    \item Two number fields \lua{year} and \lua{day}, and a string field \lua{month}:\\\lua{{year = 2022, month = "march", day = 31}}
\end{itemize}

This does make use of dynamic typing, but I doubt this is really useful. Especially the usability is a problem since the user has to select the right editor type manually. This problem is even more apparent for composite data structures.

\subsubsection{Interface with JSON APIs}
The de-facto communication format of the web, JSON\footnote{\url{https://www.json.org/json-en.html}}, is also dynamic (when not using JSON schema\footref{footnote-json-schema}). JSON is a good companion to TOP in the dynamic language Lua, as all concepts in JSON map directly to Lua concepts: numbers, strings, booleans, arrays (tables), objects (tables) and null (nil). It can be used to communicate with all kinds of JSON web APIs, such as ones providing weather conditions, address information or public transit information.

Tasks do not have any type information attached and can simply fail when their input is not in a format they can work with. They can do this because we can rely on JSON APIs to yield the right format if there was no error.

This approach however means that there is no longer an interactive component for users, since we only work with web APIs which are automatically served by websites, without user interaction. This is problematic because we just defined (in section \ref{section-top-lua}) that interactive editors are an essential component of TOP. While JSON can be hand-written by users as input to an editor, doing that is not very user-friendly compared to the alternatives.

\subsubsection{Structural type matching}
A different way to make use of the dynamic-ness of Lua is to provide multiple continuation tasks to the step combinator, where each continuation has a possibly different associated type which it accepts. The step combinator can then employ a matching algorithm to find which task it should execute based on the value of the previous task.
The matching algorithm should not only match the primitive type, but should also be able to match more complex structures like lists, or tables with specific fields. The major difference with the first option "adding types" and with statically typed languages is that you can add continuations for multiple different types to the step combinator, and that the output type of editors can still change at runtime.

There are many different ways to design such a matching algorithm, as there are many design considerations. When multiple tasks would match some value, the algorithm could find the first match, or the best match. Finding the best match requires defining a measure of match quality. What happens to tables that have more fields than the task requires?

You may think that an editor task before a step combinator can use the type information of tasks after the combinator to automatically deduce the right editor type to display. However, this goes against the TOP principle that tasks are autonomous: they do not depend on other tasks. What we can do is manually make a different editor for each type of output.

This is the direction we will go into for this thesis, for the following reasons:
it keeps the core concepts of TOP with user interaction,
it makes use of the dynamic typing of Lua,
it works in a way that is not possible with the current TOP implementations
% in the statically typed functional language Clean,
and lastly I think it is the most interesting and novel idea.

\subsection{Tables in editors}
Tables can be visually represented as a sequence of key-value pairs, with a ``$+$'' button for adding a new pair and a ``$-$'' button for removing a pair. A value without key acts as an array entry. These entries implicitly get a numeric key, just like in Lua. They can be displayed one after the other, without keys displayed. Tables that contain tables can be represented in two ways: either by a single element that, when clicked, navigates to the inner table entirely (like entering a directory in a file explorer), or by a collapsible indented list (like the sidebar in a file explorer). They both provide the same functionality, which one to choose comes down to preference or implementation details.
